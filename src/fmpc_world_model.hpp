/*
 * fmpc_world_model microblx function block (autogenerated, don't edit)
 */

#ifndef FMPC_MORLD_MODEL_HPP_
#define FMPC_MORLD_MODEL_HPP_

#include <ubx.h>

/* includes types and type metadata */


/* block meta information */
char fmpc_world_model_meta[] =
        " { doc='',"
        "   real-time=true,"
        "}";

/* declaration of block configuration */
ubx_config_t fmpc_world_model_config[] = {
        { .name="wm_handle", .type_name = "struct rsg_wm_handle", .doc="Handle to the world wodel instance. This parameter is mandatory." },
        { .name="use_mockup", .type_name = "bool", .doc="If true an internal mockup is used rather than a real system. To be used for testing." },
        { NULL },
};

/* declaration port block ports */
ubx_port_t fmpc_world_model_ports[] = {
        { .name="fmpc_virtual_fence", .out_type_name="float", .out_data_len=4, .doc="AABB bounding box to constrain the FMPC. [Ax, Ay, Bx, By]"  },
        { .name="fmpc_obstacle", .out_type_name="float", .out_data_len=3, .doc="Obstacle represented as a circle with the following parameters: [x,y,r]"  },
        { .name="fmpc_goal_pose", .out_type_name="float", .out_data_len=2, .doc="A new goal setpoint represented as a point: [x,y]. Theta (rotation) is not supported."  },
        { .name="fmpc_robot_pose", .in_type_name="float", .in_data_len=2, .doc="The current pose of the robot represented as a point: [x,y]. Theta (rotation) is not supported."  },
        { NULL },
};

/* declare a struct port_cache */
struct fmpc_world_model_port_cache {
        ubx_port_t* fmpc_virtual_fence;
        ubx_port_t* fmpc_obstacle;
        ubx_port_t* fmpc_goal_pose;
        ubx_port_t* fmpc_robot_pose;
};

/* declare a helper function to update the port cache this is necessary
 * because the port ptrs can change if ports are dynamically added or
 * removed. This function should hence be called after all
 * initialization is done, i.e. typically in 'start'
 */
static void update_port_cache(ubx_block_t *b, struct fmpc_world_model_port_cache *pc)
{
        pc->fmpc_virtual_fence = ubx_port_get(b, "fmpc_virtual_fence");
        pc->fmpc_obstacle = ubx_port_get(b, "fmpc_obstacle");
        pc->fmpc_goal_pose = ubx_port_get(b, "fmpc_goal_pose");
        pc->fmpc_robot_pose = ubx_port_get(b, "fmpc_robot_pose");
}


/* for each port type, declare convenience functions to read/write from ports */
def_write_arr_fun(write_fmpc_virtual_fence_4, float, 4)
//def_write_arr_fun(write_fmpc_obstacle_3, float, 3)
//def_write_arr_fun(write_fmpc_goal_pose_2, float, 2)
//def_read_arr_fun(read_fmpc_robot_pose_2, float, 2)

/* block operation forward declarations */
int fmpc_world_model_init(ubx_block_t *b);
int fmpc_world_model_start(ubx_block_t *b);
void fmpc_world_model_stop(ubx_block_t *b);
void fmpc_world_model_cleanup(ubx_block_t *b);
void fmpc_world_model_step(ubx_block_t *b);


/* put everything together */
ubx_block_t fmpc_world_model_block = {
        .name = "fmpc_world_model",
        .type = BLOCK_TYPE_COMPUTATION,
        .meta_data = fmpc_world_model_meta,
        .configs = fmpc_world_model_config,
        .ports = fmpc_world_model_ports,

        /* ops */
        .init = fmpc_world_model_init,
        .start = fmpc_world_model_start,
        .stop = fmpc_world_model_stop,
        .cleanup = fmpc_world_model_cleanup,
        .step = fmpc_world_model_step,
};


/* fmpc_world_model module init and cleanup functions */
int fmpc_world_model_mod_init(ubx_node_info_t* ni)
{
        DBG(" ");
        int ret = -1;

        if(ubx_block_register(ni, &fmpc_world_model_block) != 0)
                goto out;

        ret=0;
out:
        return ret;
}

void fmpc_world_model_mod_cleanup(ubx_node_info_t *ni)
{
        DBG(" ");
        ubx_block_unregister(ni, "fmpc_world_model");
}

UBX_MODULE_INIT(fmpc_world_model_mod_init)
UBX_MODULE_CLEANUP(fmpc_world_model_mod_cleanup)

#endif /* FMPC_MORLD_MODEL_HPP_ */



/* EOF */


